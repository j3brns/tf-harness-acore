# GitLab CI/CD Pipeline for Bedrock AgentCore Terraform
# Uses Web Identity Federation (WIF) for AWS authentication
# Requires: CI_ENVIRONMENT_ROLE_ARN_DEV/TEST/PROD, TF_STATE_BUCKET_DEV/TEST/PROD

image:
  name: amazon/aws-cli:latest
  entrypoint: [""]

stages:
  - validate     # Terraform syntax, formatting (no AWS)
  - lint         # Security scanning, best practices (no AWS)
  - test         # Example validation, Cedar policies (no AWS)
  - plan-dev     # Plan dev deployment (no apply)
  - deploy-dev   # Auto-deploy to dev (AWS dev account)
  - smoke-test-dev # Verify dev deployment
  - promote-test # Manual promotion gate before any test env actions
  - plan-test    # Plan test deployment for review
  - deploy-test  # Manual deploy to test (AWS test account)
  - smoke-test-test # Verify test deployment
  - gate-prod    # Verify promotion prerequisites before prod
  - plan-prod    # Plan prod deployment for review
  - deploy-prod  # Manual deploy to prod (AWS prod account)
  - smoke-test-prod # Verify prod deployment

variables:
  REPO_ROOT: ${CI_PROJECT_DIR}
  TF_ROOT: ${CI_PROJECT_DIR}/terraform
  TF_VERSION: "1.14.3"
  TFLINT_VERSION: "0.50.3"
  AWS_DEFAULT_REGION: eu-west-2
  DEV_EXAMPLE: "1-hello-world"
  TEST_EXAMPLE: "2-gateway-tool"
  PROD_EXAMPLE: "3-deepresearch"

# =============================================================================
# Template: Install tools (cached binary, not re-downloaded each job)
# =============================================================================
.install_tools:
  before_script:
    - |
      # Install system deps (minimal, fast)
      if command -v yum >/dev/null 2>&1; then
        yum install -y --allowerasing unzip zip jq git curl python3.12 python3.12-pip --quiet
        # Force python3 to point to python3.12
        ln -sf /usr/bin/python3.12 /usr/bin/python3
        python3 --version
      elif command -v apk >/dev/null 2>&1; then
        apk add --no-cache unzip jq git curl
      elif command -v apt-get >/dev/null 2>&1; then
        apt-get update -qq && apt-get install -y --no-install-recommends unzip jq git curl
      else
        echo "ERROR: No supported package manager found"; exit 1
      fi
    - |
      # Install Terraform (cached between jobs via GitLab cache)
      if ! command -v terraform >/dev/null 2>&1; then
        curl -sLo /tmp/tf.zip "https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip"
        unzip -q /tmp/tf.zip -d /usr/local/bin && rm /tmp/tf.zip
        chmod +x /usr/local/bin/terraform
      fi
      terraform version
    - |
      # Ensure AWS CLI is available for jobs that inherit .aws_auth with non-AWS base images
      if ! command -v aws >/dev/null 2>&1; then
        if command -v yum >/dev/null 2>&1; then
          yum install -y awscli --quiet
        elif command -v apk >/dev/null 2>&1; then
          apk add --no-cache aws-cli
        elif command -v apt-get >/dev/null 2>&1; then
          apt-get update -qq && apt-get install -y --no-install-recommends awscli
        else
          echo "ERROR: No supported package manager found for AWS CLI installation"; exit 1
        fi
      fi
      aws --version

.install_tools_with_tflint:
  before_script:
    - !reference [.install_tools, before_script]
    - |
      if ! command -v tflint >/dev/null 2>&1; then
        curl -sLo /tmp/tflint.zip "https://github.com/terraform-linters/tflint/releases/download/v${TFLINT_VERSION}/tflint_linux_amd64.zip"
        unzip -q /tmp/tflint.zip -d /usr/local/bin && rm /tmp/tflint.zip
        chmod +x /usr/local/bin/tflint
      fi

# =============================================================================
# Template: Authenticate with AWS via WIF
# =============================================================================
.aws_auth:
  id_tokens:
    CI_JOB_JWT_V2:
      aud: https://gitlab.com
  before_script:
    - !reference [.install_tools, before_script]
    - |
      if [ -z "$CI_JOB_JWT_V2" ]; then
        echo "ERROR: CI_JOB_JWT_V2 is not set. WIF requires id_tokens configuration."
        exit 1
      fi
      if [ -z "$AWS_ROLE_ARN" ]; then
        echo "ERROR: AWS_ROLE_ARN is not set for environment: $CI_ENVIRONMENT_NAME"
        exit 1
      fi
      # Write token securely and ensure cleanup on exit
      trap 'rm -f /tmp/oidc_token' EXIT
      echo "$CI_JOB_JWT_V2" > /tmp/oidc_token
      chmod 600 /tmp/oidc_token
      export AWS_WEB_IDENTITY_TOKEN_FILE=/tmp/oidc_token
      export AWS_ROLE_SESSION_NAME="gitlab-${CI_PROJECT_PATH_SLUG}-${CI_PIPELINE_ID}"
      if ! aws sts get-caller-identity; then
        echo "ERROR: WIF authentication failed. Check AWS_ROLE_ARN and OIDC provider setup."
        exit 1
      fi

# =============================================================================
# Template: Generate backend config (unique file per environment to avoid collision)
# =============================================================================
.generate_backend:
  script:
    - |
      BACKEND_FILE="$TF_ROOT/backend-${CI_ENVIRONMENT_NAME}.tf"
      # Remove any other backend files to avoid conflicts
      find "$TF_ROOT" -maxdepth 1 -name 'backend-*.tf' -not -name "backend-${CI_ENVIRONMENT_NAME}.tf" -delete
      cat > "$BACKEND_FILE" <<EOF
      terraform {
        backend "s3" {
          bucket       = "${TF_STATE_BUCKET}"
          key          = "agentcore/${CI_ENVIRONMENT_NAME}/terraform.tfstate"
          region       = "${AWS_DEFAULT_REGION}"
          encrypt      = true
          use_lockfile = true
        }
      }
      EOF
      terraform init -reconfigure -input=false

# =============================================================================
# Template: Failure notification
# =============================================================================
.notify_failure:
  after_script:
    - |
      if [ "$CI_JOB_STATUS" = "failed" ] && [ -n "$SLACK_WEBHOOK_URL" ]; then
        curl -s -X POST "$SLACK_WEBHOOK_URL" \
          -H 'Content-Type: application/json' \
          -d "{\"text\":\"❌ Pipeline failed\\nJob: \`$CI_JOB_NAME\`\\nBranch: \`$CI_COMMIT_BRANCH\`\\nPipeline: $CI_PIPELINE_URL\"}"
      fi

# =============================================================================
# Cache for terraform providers between jobs (paths relative to CI_PROJECT_DIR)
# =============================================================================
.terraform_cache:
  cache:
    key: terraform-providers-${TF_VERSION}
    paths:
      - terraform/.terraform/
      - terraform/.terraform.lock.hcl
    policy: pull-push

# =============================================================================
# STAGE 1: VALIDATE (No AWS resources)
# =============================================================================

validate:fmt:
  stage: validate
  extends: [.install_tools, .notify_failure]
  script:
    - cd $TF_ROOT
    - terraform fmt -check -recursive
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_BRANCH

validate:syntax:
  stage: validate
  extends: [.install_tools, .notify_failure]
  script:
    - cd $TF_ROOT
    - terraform init -backend=false -input=false
    - terraform validate
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_BRANCH

validate:docs-and-tests:
  stage: validate
  extends: [.install_tools, .notify_failure]
  script:
    - |
      set -euo pipefail
      TARGET="${CI_MERGE_REQUEST_TARGET_BRANCH_NAME:-$CI_DEFAULT_BRANCH}"
      git fetch origin "$TARGET"
      CHANGED=$(git diff --name-only "origin/$TARGET"...HEAD)
      if printf '%s\n' "$CHANGED" | grep -qE "\.tf$"; then
        printf '%s\n' "$CHANGED" | grep -qE "\.md$" \
          || { echo "ERROR: Terraform changed without docs update"; exit 1; }
        printf '%s\n' "$CHANGED" | grep -qE "^(terraform/tests/|terraform/scripts/validate_examples\.sh|examples/.*/tests/)" \
          || { echo "ERROR: Terraform changed without tests"; exit 1; }
      fi
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# =============================================================================
# STAGE 2: LINT (No AWS resources)
# =============================================================================

lint:tflint:
  stage: lint
  extends: [.install_tools_with_tflint, .notify_failure]
  script:
    - cd $TF_ROOT
    - tflint --init
    - tflint --recursive --format compact --config $TF_ROOT/.tflint.hcl
  allow_failure: false
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

lint:checkov:
  stage: lint
  image:
    name: bridgecrew/checkov:latest
    entrypoint: [""]
  extends: .notify_failure
  script:
    - cd $TF_ROOT
    - checkov -d . --framework terraform --quiet --compact
        --config-file .checkov.yaml
        --output cli --output junitxml > checkov-report.xml
  artifacts:
    reports:
      junit: $TF_ROOT/checkov-report.xml
    paths:
      - $TF_ROOT/checkov-report.xml
    expire_in: 7 days
  allow_failure: false
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# =============================================================================
# STAGE 3: TEST (No AWS resources)
# =============================================================================

test:examples:
  stage: test
  extends: [.install_tools, .notify_failure]
  script:
    - cd $TF_ROOT
    - terraform init -backend=false -input=false
    - bash $TF_ROOT/scripts/validate_examples.sh
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

test:cedar-policies:
  stage: test
  extends: [.install_tools, .notify_failure]
  script:
    - |
      POLICY_DIR="$TF_ROOT/modules/agentcore-governance/cedar_policies"
      if [ ! -d "$POLICY_DIR" ]; then
        echo "No Cedar policies directory found, skipping"
        exit 0
      fi
      # Install cedar-policy-cli if available, otherwise fail with helpful message
      if ! command -v cedar >/dev/null 2>&1; then
        echo "WARNING: cedar CLI not installed. Install via: cargo install cedar-policy-cli"
        echo "Falling back to schema-less syntax check (not fully reliable)"
      fi
      FAILED=0
      for policy in "$POLICY_DIR"/*.cedar; do
        [ -f "$policy" ] || continue
        echo "Validating: $(basename $policy)"
        if command -v cedar >/dev/null 2>&1; then
          cedar validate --policies "$policy" || FAILED=1
        else
          # Verify file is non-empty and parseable as text
          [ -s "$policy" ] || { echo "ERROR: Empty policy file: $policy"; FAILED=1; }
        fi
      done
      exit $FAILED
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

test:python-hello-world:
  stage: test
  image: python:3.12-slim
  script:
    - pip install -q --upgrade pip
    - cd $REPO_ROOT/examples/1-hello-world/agent-code
    - pip install -q -e ".[dev]"
    - python -m pytest tests/ -v --tb=short --junitxml=test-results.xml
  artifacts:
    reports:
      junit: $REPO_ROOT/examples/1-hello-world/agent-code/test-results.xml
    expire_in: 7 days
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - changes:
        - examples/1-hello-world/**/*

test:python-gateway-tool:
  stage: test
  image: python:3.12-slim
  script:
    - pip install -q --upgrade pip
    - cd $REPO_ROOT/examples/2-gateway-tool/agent-code
    - pip install -q -e ".[dev]"
    - python -m pytest tests/ -v --tb=short --junitxml=test-results.xml
  artifacts:
    reports:
      junit: $REPO_ROOT/examples/2-gateway-tool/agent-code/test-results.xml
    expire_in: 7 days
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - changes:
        - examples/2-gateway-tool/**/*

test:python-deepresearch:
  stage: test
  image: python:3.12-slim
  script:
    - pip install -q --upgrade pip
    - cd $REPO_ROOT/examples/3-deepresearch/agent-code
    - pip install -q -e ".[dev]"
    - python -m pytest tests/unit -v --tb=short --junitxml=unit-results.xml
  artifacts:
    reports:
      junit: $REPO_ROOT/examples/3-deepresearch/agent-code/unit-results.xml
    expire_in: 7 days
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - changes:
        - examples/3-deepresearch/**/*

test:python-research:
  stage: test
  image: python:3.12-slim
  script:
    - pip install -q --upgrade pip
    - cd $REPO_ROOT/examples/4-research/agent-code
    - pip install -q -e ".[dev]"
    - python -m pytest tests/ -v --tb=short --junitxml=test-results.xml
  artifacts:
    reports:
      junit: $REPO_ROOT/examples/4-research/agent-code/test-results.xml
    expire_in: 7 days
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - changes:
        - examples/4-research/**/*

# =============================================================================
# STAGE 4: PLAN DEV
# =============================================================================

plan:dev:
  stage: plan-dev
  extends: [.aws_auth, .terraform_cache, .notify_failure]
  environment:
    name: dev
  variables:
    AWS_ROLE_ARN: ${CI_ENVIRONMENT_ROLE_ARN_DEV}
    TF_STATE_BUCKET: ${TF_STATE_BUCKET_DEV}
    TF_VAR_environment: "dev"
    TF_VAR_app_id: "acore-dev-v1"
    TF_VAR_lambda_architecture: "arm64"
  script:
    - cd $TF_ROOT
    - !reference [.generate_backend, script]
    - terraform plan
        -var-file="$REPO_ROOT/examples/${DEV_EXAMPLE}/terraform.tfvars"
        -input=false
        -out=dev.tfplan
    - terraform show -no-color dev.tfplan | tee dev-plan.txt
  artifacts:
    paths:
      - $TF_ROOT/dev.tfplan
      - $TF_ROOT/dev-plan.txt
    expire_in: 1 hour
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success

# =============================================================================
# STAGE 5: DEPLOY DEV (Auto on main merge)
# =============================================================================

deploy:dev:
  stage: deploy-dev
  extends: [.aws_auth, .terraform_cache, .notify_failure]
  environment:
    name: dev
    url: https://console.aws.amazon.com/bedrock/
  variables:
    AWS_ROLE_ARN: ${CI_ENVIRONMENT_ROLE_ARN_DEV}
    TF_STATE_BUCKET: ${TF_STATE_BUCKET_DEV}
    TF_VAR_environment: "dev"
    TF_VAR_app_id: "acore-dev-v1"
    TF_VAR_lambda_architecture: "arm64"
  needs: [plan:dev]
  resource_group: terraform-dev
  timeout: 30m
  script:
    - cd $TF_ROOT
    - !reference [.generate_backend, script]
    - |
      if ! terraform apply -auto-approve -input=false dev.tfplan; then
        echo "ERROR: Deploy failed. Saving state snapshot for diagnostics."
        terraform state pull > failed-state-$(date +%s).json || echo "WARNING: Could not save state snapshot"
        exit 1
      fi
    - terraform output -json > outputs-dev.json
  artifacts:
    paths:
      - $TF_ROOT/outputs-dev.json
      - $TF_ROOT/failed-state-*.json
    expire_in: 7 days
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success

# =============================================================================
# STAGE: SMOKE TEST DEV
# =============================================================================

smoke-test:dev:
  stage: smoke-test-dev
  extends: [.aws_auth, .notify_failure]
  image: python:3.12-slim
  variables:
    AWS_ROLE_ARN: ${CI_ENVIRONMENT_ROLE_ARN_DEV}
  script:
    - pip install -q boto3
    - cd $TF_ROOT
    - python scripts/validate_bff.py
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success

# =============================================================================
# STAGE 6: PROMOTE TEST (Manual gate - no test env actions without promotion)
# =============================================================================

promote:test:
  stage: promote-test
  extends: [.install_tools, .notify_failure]
  script:
    - |
      set -euo pipefail
      echo "Validating promotion prerequisites for $CI_COMMIT_SHA on branch $CI_COMMIT_BRANCH"
      PIPELINES_JSON=$(curl -sS --fail --header "JOB-TOKEN: $CI_JOB_TOKEN" \
        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/pipelines?sha=$CI_COMMIT_SHA&status=success&per_page=100")
      MAIN_OK=$(printf '%s' "$PIPELINES_JSON" | jq -r '[.[] | select(.ref == $main_ref)] | length' --arg main_ref "$CI_DEFAULT_BRANCH")
      if [ "$MAIN_OK" -lt 1 ]; then
        echo "ERROR: No successful $CI_DEFAULT_BRANCH pipeline found for this SHA. Promote from dev/main first."
        exit 1
      fi
      echo "PROMOTION_TO_TEST_APPROVED=true" > promote-test.env
      echo "Promotion approved for test."
  artifacts:
    reports:
      dotenv: promote-test.env
    expire_in: 7 days
  when: manual
  allow_failure: false
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^release\/.*/

# =============================================================================
# STAGE 7: PLAN TEST (Review before approving deploy)
# =============================================================================

plan:test:
  stage: plan-test
  extends: [.aws_auth, .terraform_cache, .notify_failure]
  needs:
    - job: promote:test
      artifacts: true
  environment:
    name: test
  variables:
    AWS_ROLE_ARN: ${CI_ENVIRONMENT_ROLE_ARN_TEST}
    TF_STATE_BUCKET: ${TF_STATE_BUCKET_TEST}
    TF_VAR_environment: "test"
    TF_VAR_app_id: "agentcore-test"
    TF_VAR_lambda_architecture: "arm64"
  script:
    - |
      if [ "${PROMOTION_TO_TEST_APPROVED:-}" != "true" ]; then
        echo "ERROR: Test promotion not approved. Trigger promote:test first."
        exit 1
      fi
    - cd $TF_ROOT
    - !reference [.generate_backend, script]
    - terraform plan
        -var-file="$REPO_ROOT/examples/${TEST_EXAMPLE}/terraform.tfvars"
        -input=false
        -out=test.tfplan
    - terraform show -no-color test.tfplan | tee test-plan.txt
  artifacts:
    paths:
      - $TF_ROOT/test.tfplan
      - $TF_ROOT/test-plan.txt
    expire_in: 4 hours
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^release\/.*/
      when: on_success

# =============================================================================
# STAGE 8: DEPLOY TEST (Manual - operator reviews plan first)
# =============================================================================

deploy:test:
  stage: deploy-test
  extends: [.aws_auth, .terraform_cache, .notify_failure]
  environment:
    name: test
    url: https://console.aws.amazon.com/bedrock/
  variables:
    AWS_ROLE_ARN: ${CI_ENVIRONMENT_ROLE_ARN_TEST}
    TF_STATE_BUCKET: ${TF_STATE_BUCKET_TEST}
    TF_VAR_environment: "test"
    TF_VAR_app_id: "agentcore-test"
    TF_VAR_lambda_architecture: "arm64"
  needs:
    - job: promote:test
      artifacts: true
    - job: plan:test
      artifacts: true
  resource_group: terraform-test
  timeout: 30m
  script:
    - |
      if [ "${PROMOTION_TO_TEST_APPROVED:-}" != "true" ]; then
        echo "ERROR: Test promotion not approved. Trigger promote:test first."
        exit 1
      fi
    - cd $TF_ROOT
    - echo "=== Plan to be applied ===" && cat test-plan.txt
    - !reference [.generate_backend, script]
    - |
      if ! terraform apply -auto-approve -input=false test.tfplan; then
        echo "ERROR: Deploy failed. Saving state snapshot for diagnostics."
        terraform state pull > failed-state-$(date +%s).json || echo "WARNING: Could not save state snapshot"
        exit 1
      fi
    - terraform output -json > outputs-test.json
  artifacts:
    paths:
      - $TF_ROOT/outputs-test.json
      - $TF_ROOT/failed-state-*.json
    expire_in: 30 days
  when: manual
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^release\/.*/

smoke-test:test:
  stage: smoke-test-test
  extends: [.aws_auth, .notify_failure]
  image: python:3.12-slim
  needs:
    - job: promote:test
      artifacts: true
    - job: deploy:test
      artifacts: true
  variables:
    AWS_ROLE_ARN: ${CI_ENVIRONMENT_ROLE_ARN_TEST}
  script:
    - |
      if [ "${PROMOTION_TO_TEST_APPROVED:-}" != "true" ]; then
        echo "ERROR: Test promotion not approved. Trigger promote:test first."
        exit 1
      fi
    - pip install -q boto3
    - cd $TF_ROOT
    - python scripts/validate_bff.py
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^release\/.*/
      when: on_success

# =============================================================================
# STAGE 9: GATE PROD (Require successful test promotion evidence)
# =============================================================================

gate:prod-from-test:
  stage: gate-prod
  extends: [.install_tools, .notify_failure]
  script:
    - |
      set -euo pipefail
      echo "Checking promotion gate for tag ${CI_COMMIT_TAG:-<none>} at SHA ${CI_COMMIT_SHA}"
      PIPELINES_JSON=$(curl -sS --fail --header "JOB-TOKEN: $CI_JOB_TOKEN" \
        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/pipelines?sha=$CI_COMMIT_SHA&status=success&per_page=100")
      RELEASE_PIPELINE_IDS=$(printf '%s' "$PIPELINES_JSON" | jq -r '.[] | select(.ref | test("^release/")) | .id')
      if [ -z "$RELEASE_PIPELINE_IDS" ]; then
        echo "ERROR: No successful release/* pipeline found for this SHA. Promote through test first."
        exit 1
      fi

      GATE_PASSED=0
      for PIPELINE_ID in $RELEASE_PIPELINE_IDS; do
        JOBS_JSON=$(curl -sS --fail --header "JOB-TOKEN: $CI_JOB_TOKEN" \
          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/pipelines/${PIPELINE_ID}/jobs?per_page=100")
        if printf '%s' "$JOBS_JSON" | jq -e '.[] | select(.name=="deploy:test" and .status=="success")' >/dev/null \
          && printf '%s' "$JOBS_JSON" | jq -e '.[] | select(.name=="smoke-test:test" and .status=="success")' >/dev/null; then
          echo "Promotion gate satisfied by release pipeline ID: ${PIPELINE_ID}"
          GATE_PASSED=1
          break
        fi
      done

      if [ "$GATE_PASSED" -ne 1 ]; then
        echo "ERROR: No successful release/* pipeline for this SHA contains deploy:test + smoke-test:test."
        exit 1
      fi
  rules:
    - if: $CI_COMMIT_TAG

# =============================================================================
# STAGE 10: PLAN PROD (Mandatory review before prod deploy)
# =============================================================================

plan:prod:
  stage: plan-prod
  extends: [.aws_auth, .terraform_cache, .notify_failure]
  environment:
    name: production
  variables:
    AWS_ROLE_ARN: ${CI_ENVIRONMENT_ROLE_ARN_PROD}
    TF_STATE_BUCKET: ${TF_STATE_BUCKET_PROD}
    TF_VAR_environment: "prod"
    TF_VAR_app_id: "agentcore-prod"
    TF_VAR_lambda_architecture: "arm64"
  needs: [gate:prod-from-test]
  script:
    - cd $TF_ROOT
    - !reference [.generate_backend, script]
    - terraform plan
        -var-file="$REPO_ROOT/examples/${PROD_EXAMPLE}/terraform.tfvars"
        -input=false
        -out=prod.tfplan
    - terraform show -no-color prod.tfplan | tee prod-plan.txt
    - |
      echo "=== PLAN SUMMARY ==="
      grep -E "^Plan:|will be created|will be destroyed|will be updated" prod-plan.txt || true
  artifacts:
    paths:
      - $TF_ROOT/prod.tfplan
      - $TF_ROOT/prod-plan.txt
    expire_in: 4 hours
  rules:
    - if: $CI_COMMIT_TAG

# =============================================================================
# STAGE 11: DEPLOY PROD (Manual - operator reviews plan output before approving)
# =============================================================================

deploy:prod:
  stage: deploy-prod
  extends: [.aws_auth, .terraform_cache, .notify_failure]
  environment:
    name: production
    url: https://console.aws.amazon.com/bedrock/
  variables:
    AWS_ROLE_ARN: ${CI_ENVIRONMENT_ROLE_ARN_PROD}
    TF_STATE_BUCKET: ${TF_STATE_BUCKET_PROD}
    TF_VAR_environment: "prod"
    TF_VAR_app_id: "agentcore-prod"
    TF_VAR_lambda_architecture: "arm64"
  needs: [plan:prod]
  resource_group: terraform-prod
  timeout: 60m
  script:
    - cd $TF_ROOT
    - echo "=== Plan to be applied ===" && cat prod-plan.txt
    - !reference [.generate_backend, script]
    - |
      if ! terraform apply -auto-approve -input=false prod.tfplan; then
        echo "ERROR: Prod deploy failed. Saving state snapshot for diagnostics."
        terraform state pull > failed-state-$(date +%s).json || echo "WARNING: Could not save state snapshot"
        exit 1
      fi
    - terraform output -json > outputs-prod.json
  artifacts:
    paths:
      - $TF_ROOT/outputs-prod.json
      - $TF_ROOT/failed-state-*.json
    expire_in: 90 days
  when: manual
  rules:
    - if: $CI_COMMIT_TAG

smoke-test:prod:
  stage: smoke-test-prod
  extends: [.aws_auth, .notify_failure]
  image: python:3.12-slim
  variables:
    AWS_ROLE_ARN: ${CI_ENVIRONMENT_ROLE_ARN_PROD}
  script:
    - pip install -q boto3
    - cd $TF_ROOT
    - python scripts/validate_bff.py
  rules:
    - if: $CI_COMMIT_TAG
      when: on_success

# =============================================================================
# SCHEDULED: DRIFT DETECTION (all environments)
# =============================================================================

.drift_template:
  stage: test
  extends: [.aws_auth, .notify_failure]
  script:
    - cd $TF_ROOT
    - !reference [.generate_backend, script]
    - |
      set +e
      terraform plan \
        -detailed-exitcode \
        -var-file="$REPO_ROOT/examples/${DRIFT_EXAMPLE}/terraform.tfvars" \
        -input=false
      EXIT_CODE=$?
      set -e
      case $EXIT_CODE in
        0) echo "✅ No drift detected in $CI_ENVIRONMENT_NAME" ;;
        2)
          echo "⚠️ DRIFT DETECTED in $CI_ENVIRONMENT_NAME"
          echo "Infrastructure differs from Terraform state."
          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            curl -s -X POST "$SLACK_WEBHOOK_URL" \
              -H 'Content-Type: application/json' \
              -d "{\"text\":\"⚠️ Drift detected in \`$CI_ENVIRONMENT_NAME\`\\nPipeline: $CI_PIPELINE_URL\"}"
          fi
          exit 1
          ;;
        *) echo "ERROR: terraform plan failed in $CI_ENVIRONMENT_NAME"; exit 1 ;;
      esac
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"

drift:dev:
  extends: .drift_template
  environment:
    name: dev
  variables:
    AWS_ROLE_ARN: ${CI_ENVIRONMENT_ROLE_ARN_DEV}
    TF_STATE_BUCKET: ${TF_STATE_BUCKET_DEV}
    TF_VAR_environment: "dev"
    DRIFT_EXAMPLE: ${DEV_EXAMPLE}

drift:test:
  extends: .drift_template
  environment:
    name: test
  variables:
    AWS_ROLE_ARN: ${CI_ENVIRONMENT_ROLE_ARN_TEST}
    TF_STATE_BUCKET: ${TF_STATE_BUCKET_TEST}
    TF_VAR_environment: "test"
    DRIFT_EXAMPLE: ${TEST_EXAMPLE}

drift:prod:
  extends: .drift_template
  environment:
    name: production
  variables:
    AWS_ROLE_ARN: ${CI_ENVIRONMENT_ROLE_ARN_PROD}
    TF_STATE_BUCKET: ${TF_STATE_BUCKET_PROD}
    TF_VAR_environment: "prod"
    DRIFT_EXAMPLE: ${PROD_EXAMPLE}

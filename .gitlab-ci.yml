# GitLab CI/CD Pipeline for Bedrock AgentCore Terraform
# Uses Web Identity Federation (WIF) for AWS authentication
# Requires: CI_ENVIRONMENT_ROLE_ARN_DEV/TEST/PROD, TF_STATE_BUCKET_DEV/TEST/PROD
# Segmented backend keys additionally require per-environment app/agent IDs (defaults below).

image:
  name: amazon/aws-cli:latest
  entrypoint: [""]

stages:
  - validate     # Terraform syntax, formatting (no AWS)
  - lint         # Security scanning, best practices (no AWS)
  - test         # Example validation, Cedar policies (no AWS)
  - plan-dev     # Plan dev deployment (no apply)
  - promote-dev  # Manual promotion gate before any dev deploy
  - deploy-dev   # Deploy to dev (AWS dev account), gated by manual promotion
  - smoke-test-dev # Verify dev deployment
  - promote-test # Manual promotion gate before any test env actions
  - plan-test    # Plan test deployment for review
  - deploy-test  # Manual deploy to test (AWS test account)
  - smoke-test-test # Verify test deployment
  - gate-prod    # Verify promotion prerequisites before prod
  - plan-prod    # Plan prod deployment for review
  - deploy-prod  # Manual deploy to prod (AWS prod account)
  - smoke-test-prod # Verify prod deployment

variables:
  REPO_ROOT: ${CI_PROJECT_DIR}
  TF_ROOT: ${CI_PROJECT_DIR}/terraform
  TF_VERSION: "1.14.3"
  TFLINT_VERSION: "0.50.3"
  AWS_DEFAULT_REGION: eu-west-2
  TF_STATE_KEY_MODE: "segmented" # Escape hatch: set to legacy-env-only during phased migration
  DEV_EXAMPLE: "1-hello-world"
  TEST_EXAMPLE: "2-gateway-tool"
  PROD_EXAMPLE: "3-deepresearch"
  DEV_TF_STATE_APP_ID: "acore-dev-v1"
  DEV_TF_STATE_AGENT_NAME: "hello-world-s3-a1b2"
  TEST_TF_STATE_APP_ID: "agentcore-test"
  TEST_TF_STATE_AGENT_NAME: "titanic-data-analyzer-c3d4"
  PROD_TF_STATE_APP_ID: "agentcore-prod"
  PROD_TF_STATE_AGENT_NAME: "deep-research-agent-e5f6"

# =============================================================================
# Template: Install tools (cached binary, not re-downloaded each job)
# =============================================================================
.install_tools:
  before_script:
    - |
      # Install system deps (minimal, fast)
      if command -v yum >/dev/null 2>&1; then
        yum install -y --allowerasing unzip zip jq git curl make nodejs npm python3.12 python3.12-pip --quiet
        # Force python3 to point to python3.12
        ln -sf /usr/bin/python3.12 /usr/bin/python3
        python3 --version
      elif command -v apk >/dev/null 2>&1; then
        apk add --no-cache unzip jq git curl
      elif command -v apt-get >/dev/null 2>&1; then
        apt-get update -qq && apt-get install -y --no-install-recommends unzip jq git curl
      else
        echo "ERROR: No supported package manager found"; exit 1
      fi
    - |
      # Install Terraform (cached between jobs via GitLab cache)
      if ! command -v terraform >/dev/null 2>&1; then
        curl -sLo /tmp/tf.zip "https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip"
        unzip -q /tmp/tf.zip -d /usr/local/bin && rm /tmp/tf.zip
        chmod +x /usr/local/bin/terraform
      fi
      terraform version
    - |
      # Ensure AWS CLI is available for jobs that inherit .aws_auth with non-AWS base images
      if ! command -v aws >/dev/null 2>&1; then
        if command -v yum >/dev/null 2>&1; then
          yum install -y awscli --quiet
        elif command -v apk >/dev/null 2>&1; then
          apk add --no-cache aws-cli
        elif command -v apt-get >/dev/null 2>&1; then
          apt-get update -qq && apt-get install -y --no-install-recommends awscli
        else
          echo "ERROR: No supported package manager found for AWS CLI installation"; exit 1
        fi
      fi
      aws --version

.install_tools_with_tflint:
  before_script:
    - !reference [.install_tools, before_script]
    - |
      if ! command -v tflint >/dev/null 2>&1; then
        curl -sLo /tmp/tflint.zip "https://github.com/terraform-linters/tflint/releases/download/v${TFLINT_VERSION}/tflint_linux_amd64.zip"
        unzip -q /tmp/tflint.zip -d /usr/local/bin && rm /tmp/tflint.zip
        chmod +x /usr/local/bin/tflint
      fi

# =============================================================================
# Template: Authenticate with AWS via WIF
# =============================================================================
.aws_auth:
  id_tokens:
    CI_JOB_JWT_V2:
      aud: https://gitlab.com
  before_script:
    - !reference [.install_tools, before_script]
    - |
      if [ -z "$CI_JOB_JWT_V2" ]; then
        echo "ERROR: CI_JOB_JWT_V2 is not set. WIF requires id_tokens configuration."
        exit 1
      fi
      if [ -z "$AWS_ROLE_ARN" ]; then
        echo "ERROR: AWS_ROLE_ARN is not set for environment: $CI_ENVIRONMENT_NAME"
        exit 1
      fi
      # Write token securely and ensure cleanup on exit
      trap 'rm -f /tmp/oidc_token' EXIT
      echo "$CI_JOB_JWT_V2" > /tmp/oidc_token
      chmod 600 /tmp/oidc_token
      export AWS_WEB_IDENTITY_TOKEN_FILE=/tmp/oidc_token
      export AWS_ROLE_SESSION_NAME="gitlab-${CI_PROJECT_PATH_SLUG}-${CI_PIPELINE_ID}"
      if ! aws sts get-caller-identity; then
        echo "ERROR: WIF authentication failed. Check AWS_ROLE_ARN and OIDC provider setup."
        exit 1
      fi

# =============================================================================
# Template: Generate backend config (unique file per environment to avoid collision)
# =============================================================================
.generate_backend:
  script:
    - |
      BACKEND_FILE="$TF_ROOT/backend-${CI_ENVIRONMENT_NAME}.tf"
      TF_STATE_KEY_MODE="${TF_STATE_KEY_MODE:-segmented}"

      slugify_backend_segment() {
        RAW_VALUE="$1"
        SEGMENT_LABEL="$2"
        SANITIZED_VALUE="$(printf '%s' "$RAW_VALUE" \
          | tr '[:upper:]' '[:lower:]' \
          | sed -E 's/[^a-z0-9._-]+/-/g; s/^-+//; s/-+$//; s/-+/-/g')"
        if [ -z "$SANITIZED_VALUE" ]; then
          echo "ERROR: ${SEGMENT_LABEL} is empty after sanitization: ${RAW_VALUE}"
          exit 1
        fi
        printf '%s' "$SANITIZED_VALUE"
      }

      case "$TF_STATE_KEY_MODE" in
        legacy-env-only)
          TF_STATE_KEY="agentcore/${CI_ENVIRONMENT_NAME}/terraform.tfstate"
          echo "WARNING: Using legacy env-only backend key via TF_STATE_KEY_MODE=${TF_STATE_KEY_MODE}"
          ;;
        segmented)
          if [ -z "${TF_STATE_APP_ID:-}" ]; then
            echo "ERROR: TF_STATE_APP_ID is required for segmented backend keys"
            exit 1
          fi
          if [ -z "${TF_STATE_AGENT_NAME:-}" ]; then
            echo "ERROR: TF_STATE_AGENT_NAME is required for segmented backend keys"
            exit 1
          fi
          TF_STATE_APP_ID_SEGMENT="$(slugify_backend_segment "$TF_STATE_APP_ID" "TF_STATE_APP_ID")"
          TF_STATE_AGENT_NAME_SEGMENT="$(slugify_backend_segment "$TF_STATE_AGENT_NAME" "TF_STATE_AGENT_NAME")"
          TF_STATE_KEY="agentcore/${CI_ENVIRONMENT_NAME}/${TF_STATE_APP_ID_SEGMENT}/${TF_STATE_AGENT_NAME_SEGMENT}/terraform.tfstate"
          ;;
        *)
          echo "ERROR: Unsupported TF_STATE_KEY_MODE: ${TF_STATE_KEY_MODE} (expected segmented or legacy-env-only)"
          exit 1
          ;;
      esac

      echo "Terraform backend key: ${TF_STATE_KEY}"
      # Remove any other backend files to avoid conflicts
      find "$TF_ROOT" -maxdepth 1 -name 'backend-*.tf' -not -name "backend-${CI_ENVIRONMENT_NAME}.tf" -delete
      cat > "$BACKEND_FILE" <<EOF
      terraform {
        backend "s3" {
          bucket       = "${TF_STATE_BUCKET}"
          key          = "${TF_STATE_KEY}"
          region       = "${AWS_DEFAULT_REGION}"
          encrypt      = true
          use_lockfile = true
        }
      }
      EOF
      terraform init -reconfigure -input=false

# =============================================================================
# Template: Failure notification
# =============================================================================
.notify_failure:
  after_script:
    - |
      if [ "$CI_JOB_STATUS" = "failed" ] && [ -n "$SLACK_WEBHOOK_URL" ]; then
        curl -s -X POST "$SLACK_WEBHOOK_URL" \
          -H 'Content-Type: application/json' \
          -d "{\"text\":\"❌ Pipeline failed\\nJob: \`$CI_JOB_NAME\`\\nBranch: \`$CI_COMMIT_BRANCH\`\\nPipeline: $CI_PIPELINE_URL\"}"
      fi

# =============================================================================
# Cache for terraform providers between jobs (paths relative to CI_PROJECT_DIR)
# =============================================================================
.terraform_cache:
  cache:
    key: terraform-providers-${TF_VERSION}-v2
    paths:
      - terraform/.terraform/
    policy: pull-push

# =============================================================================
# STAGE 1: VALIDATE (No AWS resources)
# =============================================================================

validate:fmt:
  stage: validate
  extends: [.install_tools, .notify_failure]
  script:
    - cd $TF_ROOT
    - terraform fmt -check -recursive
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_BRANCH

validate:syntax:
  stage: validate
  extends: [.install_tools, .notify_failure]
  script:
    - cd $TF_ROOT
    - terraform init -backend=false -input=false
    - terraform validate
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_BRANCH

validate:docs-and-tests:
  stage: validate
  extends: [.install_tools, .notify_failure]
  script:
    - |
      set -euo pipefail
      TARGET="${CI_MERGE_REQUEST_TARGET_BRANCH_NAME:-$CI_DEFAULT_BRANCH}"
      git fetch origin "$TARGET"
      CHANGED=$(git diff --name-only "origin/$TARGET"...HEAD)
      if printf '%s\n' "$CHANGED" | grep -qE "\.tf$"; then
        printf '%s\n' "$CHANGED" | grep -qE "\.md$" \
          || { echo "ERROR: Terraform changed without docs update"; exit 1; }
        printf '%s\n' "$CHANGED" | grep -qE "^(terraform/tests/|terraform/scripts/validate_examples\.sh|examples/.*/tests/)" \
          || { echo "ERROR: Terraform changed without tests"; exit 1; }
      fi
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

validate:version-metadata:
  stage: validate
  extends: [.install_tools, .notify_failure]
  script:
    - cd $REPO_ROOT
    - make validate-version-metadata
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

validate:openapi-client-drift:
  stage: validate
  extends: [.install_tools, .notify_failure]
  script:
    - cd $REPO_ROOT
    - make generate-openapi
    - make check-openapi-client
    - git diff --exit-code -- docs/api/mcp-tools-v1.openapi.json
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# =============================================================================
# STAGE 2: LINT (No AWS resources)
# =============================================================================

lint:tflint:
  stage: lint
  extends: [.install_tools_with_tflint, .notify_failure]
  script:
    - cd $TF_ROOT
    - tflint --init
    - tflint --recursive --format compact --config $TF_ROOT/.tflint.hcl
  allow_failure: false
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

lint:checkov:
  stage: lint
  image:
    name: bridgecrew/checkov:latest
    entrypoint: [""]
  extends: .notify_failure
  script:
    - cd $TF_ROOT
    - checkov -d . --framework terraform --quiet --compact
        --config-file .checkov.yaml
        --output cli --output junitxml > checkov-report.xml
  artifacts:
    reports:
      junit: $TF_ROOT/checkov-report.xml
    paths:
      - $TF_ROOT/checkov-report.xml
    expire_in: 7 days
  allow_failure: false
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# =============================================================================
# STAGE 3: TEST (No AWS resources)
# =============================================================================

test:examples:
  stage: test
  extends: [.install_tools, .notify_failure]
  script:
    - cd $TF_ROOT
    - terraform init -backend=false -input=false
    - bash $TF_ROOT/scripts/validate_examples.sh
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

test:cedar-policies:
  stage: test
  extends: [.install_tools, .notify_failure]
  script:
    - |
      POLICY_DIR="$TF_ROOT/modules/agentcore-governance/cedar_policies"
      if [ ! -d "$POLICY_DIR" ]; then
        echo "No Cedar policies directory found, skipping"
        exit 0
      fi
      # Install cedar-policy-cli if available, otherwise fail with helpful message
      if ! command -v cedar >/dev/null 2>&1; then
        echo "WARNING: cedar CLI not installed. Install via: cargo install cedar-policy-cli"
        echo "Falling back to schema-less syntax check (not fully reliable)"
      fi
      FAILED=0
      for policy in "$POLICY_DIR"/*.cedar; do
        [ -f "$policy" ] || continue
        echo "Validating: $(basename $policy)"
        if command -v cedar >/dev/null 2>&1; then
          cedar validate --policies "$policy" || FAILED=1
        else
          # Verify file is non-empty and parseable as text
          [ -s "$policy" ] || { echo "ERROR: Empty policy file: $policy"; FAILED=1; }
        fi
      done
      exit $FAILED
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

test:python-hello-world:
  stage: test
  image: python:3.12-slim
  script:
    - pip install -q --upgrade pip
    - cd $REPO_ROOT/examples/1-hello-world/agent-code
    - pip install -q -e ".[dev]"
    - python -m pytest tests/ -v --tb=short --junitxml=test-results.xml
  artifacts:
    reports:
      junit: $REPO_ROOT/examples/1-hello-world/agent-code/test-results.xml
    expire_in: 7 days
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - changes:
        - examples/1-hello-world/**/*

test:python-gateway-tool:
  stage: test
  image: python:3.12-slim
  script:
    - pip install -q --upgrade pip
    - cd $REPO_ROOT/examples/2-gateway-tool/agent-code
    - pip install -q -e ".[dev]"
    - python -m pytest tests/ -v --tb=short --junitxml=test-results.xml
  artifacts:
    reports:
      junit: $REPO_ROOT/examples/2-gateway-tool/agent-code/test-results.xml
    expire_in: 7 days
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - changes:
        - examples/2-gateway-tool/**/*

test:python-deepresearch:
  stage: test
  image: python:3.12-slim
  script:
    - pip install -q --upgrade pip
    - cd $REPO_ROOT/examples/3-deepresearch/agent-code
    - pip install -q -e ".[dev]"
    - python -m pytest tests/unit -v --tb=short --junitxml=unit-results.xml
  artifacts:
    reports:
      junit: $REPO_ROOT/examples/3-deepresearch/agent-code/unit-results.xml
    expire_in: 7 days
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - changes:
        - examples/3-deepresearch/**/*

test:python-research:
  stage: test
  image: python:3.12-slim
  script:
    - pip install -q --upgrade pip
    - cd $REPO_ROOT/examples/4-research/agent-code
    - pip install -q -e ".[dev]"
    - python -m pytest tests/ -v --tb=short --junitxml=test-results.xml
  artifacts:
    reports:
      junit: $REPO_ROOT/examples/4-research/agent-code/test-results.xml
    expire_in: 7 days
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - changes:
        - examples/4-research/**/*

# =============================================================================
# STAGE 4: PLAN DEV
# =============================================================================

plan:dev:
  stage: plan-dev
  extends: [.aws_auth, .terraform_cache, .notify_failure]
  environment:
    name: dev
  variables:
    AWS_ROLE_ARN: ${CI_ENVIRONMENT_ROLE_ARN_DEV}
    TF_STATE_BUCKET: ${TF_STATE_BUCKET_DEV}
    TF_STATE_APP_ID: ${DEV_TF_STATE_APP_ID}
    TF_STATE_AGENT_NAME: ${DEV_TF_STATE_AGENT_NAME}
    TF_VAR_environment: "dev"
    TF_VAR_app_id: "acore-dev-v1"
    TF_VAR_lambda_architecture: "arm64"
  script:
    - cd $TF_ROOT
    - !reference [.generate_backend, script]
    - terraform plan
        -var-file="$REPO_ROOT/examples/${DEV_EXAMPLE}/terraform.tfvars"
        -input=false
        -out=dev.tfplan
    - terraform show -no-color dev.tfplan | tee dev-plan.txt
  artifacts:
    paths:
      - $TF_ROOT/dev.tfplan
      - $TF_ROOT/dev-plan.txt
    expire_in: 1 hour
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success

# =============================================================================
# STAGE 5: PROMOTE DEV (Manual gate before deploy)
# =============================================================================

promote:dev:
  stage: promote-dev
  extends: [.install_tools, .notify_failure]
  script:
    - |
      set -euo pipefail
      EVIDENCE_DIR="promotion-evidence"
      EVIDENCE_FILE="${EVIDENCE_DIR}/promote-dev-evidence-${CI_COMMIT_SHA}.json"
      mkdir -p "$EVIDENCE_DIR"
      echo "Promotion approved for dev deployment on ${CI_COMMIT_SHA}"
      cat > "$EVIDENCE_FILE" <<EOF
      {
        "gate": "promote:dev",
        "commit_sha": "${CI_COMMIT_SHA}",
        "pipeline_id": "${CI_PIPELINE_ID}",
        "job_id": "${CI_JOB_ID}",
        "ref": "${CI_COMMIT_REF_NAME}",
        "pipeline_source": "${CI_PIPELINE_SOURCE}",
        "approved_at_utc": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
      }
      EOF
      echo "PROMOTION_TO_DEV_APPROVED=true" > promote-dev.env
      echo "PROMOTE_DEV_EVIDENCE_FILE=${EVIDENCE_FILE}" >> promote-dev.env
      echo "PROMOTE_DEV_EVIDENCE_SHA=${CI_COMMIT_SHA}" >> promote-dev.env
  artifacts:
    reports:
      dotenv: promote-dev.env
    paths:
      - promotion-evidence/
    expire_in: 7 days
  when: manual
  allow_failure: false
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
    - when: never

# =============================================================================
# STAGE 6: DEPLOY DEV (Gated by promote:dev)
# =============================================================================

deploy:dev:
  stage: deploy-dev
  extends: [.aws_auth, .terraform_cache, .notify_failure]
  environment:
    name: dev
    url: https://console.aws.amazon.com/bedrock/
  variables:
    AWS_ROLE_ARN: ${CI_ENVIRONMENT_ROLE_ARN_DEV}
    TF_STATE_BUCKET: ${TF_STATE_BUCKET_DEV}
    TF_STATE_APP_ID: ${DEV_TF_STATE_APP_ID}
    TF_STATE_AGENT_NAME: ${DEV_TF_STATE_AGENT_NAME}
    TF_VAR_environment: "dev"
    TF_VAR_app_id: "acore-dev-v1"
    TF_VAR_lambda_architecture: "arm64"
  needs:
    - job: plan:dev
      artifacts: true
    - job: promote:dev
      artifacts: true
  resource_group: terraform-dev
  timeout: 30m
  script:
    - |
      if [ "${PROMOTION_TO_DEV_APPROVED:-}" != "true" ]; then
        echo "ERROR: Dev promotion not approved. Trigger promote:dev first."
        exit 1
      fi
    - cd $TF_ROOT
    - !reference [.generate_backend, script]
    - |
      if ! terraform apply -auto-approve -input=false dev.tfplan; then
        echo "ERROR: Deploy failed. Saving state snapshot for diagnostics."
        terraform state pull > failed-state-$(date +%s).json || echo "WARNING: Could not save state snapshot"
        exit 1
      fi
    - terraform output -json > outputs-dev.json
  artifacts:
    paths:
      - $TF_ROOT/outputs-dev.json
      - $TF_ROOT/failed-state-*.json
    expire_in: 7 days
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success

# =============================================================================
# STAGE 7: SMOKE TEST DEV
# =============================================================================

smoke-test:dev:
  stage: smoke-test-dev
  extends: [.aws_auth, .notify_failure]
  image: python:3.12-slim
  variables:
    AWS_ROLE_ARN: ${CI_ENVIRONMENT_ROLE_ARN_DEV}
  script:
    - pip install -q boto3
    - cd $TF_ROOT
    - python scripts/validate_bff.py
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success

# =============================================================================
# STAGE 8: PROMOTE TEST (Manual gate - no test env actions without promotion)
# =============================================================================

promote:test:
  stage: promote-test
  extends: [.install_tools, .notify_failure]
  script:
    - |
      set -euo pipefail
      echo "Validating promotion prerequisites for $CI_COMMIT_SHA on branch $CI_COMMIT_BRANCH"
      JOBS_JSON=$(curl -sS --fail --header "JOB-TOKEN: $CI_JOB_TOKEN" \
        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/pipelines/$CI_PIPELINE_ID/jobs?per_page=100")
      if ! printf '%s' "$JOBS_JSON" | jq -e '.[] | select(.name=="promote:dev" and .status=="success")' >/dev/null; then
        echo "ERROR: promote:dev is not successful in this pipeline. Promote dev first."
        exit 1
      fi
      if ! printf '%s' "$JOBS_JSON" | jq -e '.[] | select(.name=="deploy:dev" and .status=="success")' >/dev/null; then
        echo "ERROR: deploy:dev is not successful in this pipeline. Promote dev first."
        exit 1
      fi
      if ! printf '%s' "$JOBS_JSON" | jq -e '.[] | select(.name=="smoke-test:dev" and .status=="success")' >/dev/null; then
        echo "ERROR: smoke-test:dev is not successful in this pipeline. Promote dev first."
        exit 1
      fi
      EVIDENCE_DIR="promotion-evidence"
      EVIDENCE_FILE="${EVIDENCE_DIR}/promote-test-evidence-${CI_COMMIT_SHA}.json"
      mkdir -p "$EVIDENCE_DIR"
      cat > "$EVIDENCE_FILE" <<EOF
      {
        "gate": "promote:test",
        "commit_sha": "${CI_COMMIT_SHA}",
        "pipeline_id": "${CI_PIPELINE_ID}",
        "job_id": "${CI_JOB_ID}",
        "ref": "${CI_COMMIT_REF_NAME}",
        "pipeline_source": "${CI_PIPELINE_SOURCE}",
        "approved_at_utc": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
        "prerequisites": [
          "promote:dev",
          "deploy:dev",
          "smoke-test:dev"
        ]
      }
      EOF
      echo "PROMOTION_TO_TEST_APPROVED=true" > promote-test.env
      echo "PROMOTE_TEST_EVIDENCE_FILE=${EVIDENCE_FILE}" >> promote-test.env
      echo "PROMOTE_TEST_EVIDENCE_SHA=${CI_COMMIT_SHA}" >> promote-test.env
      echo "Promotion approved for test."
  artifacts:
    reports:
      dotenv: promote-test.env
    paths:
      - promotion-evidence/
    expire_in: 7 days
  when: manual
  allow_failure: false
  rules:
    - if: $CI_PIPELINE_SOURCE =~ /^(web|api)$/ && $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
    - when: never

# =============================================================================
# STAGE 9: PLAN TEST (Review before approving deploy)
# =============================================================================

plan:test:
  stage: plan-test
  extends: [.aws_auth, .terraform_cache, .notify_failure]
  needs:
    - job: promote:test
      artifacts: true
  environment:
    name: test
  variables:
    AWS_ROLE_ARN: ${CI_ENVIRONMENT_ROLE_ARN_TEST}
    TF_STATE_BUCKET: ${TF_STATE_BUCKET_TEST}
    TF_STATE_APP_ID: ${TEST_TF_STATE_APP_ID}
    TF_STATE_AGENT_NAME: ${TEST_TF_STATE_AGENT_NAME}
    TF_VAR_environment: "test"
    TF_VAR_app_id: "agentcore-test"
    TF_VAR_lambda_architecture: "arm64"
  script:
    - |
      if [ "${PROMOTION_TO_TEST_APPROVED:-}" != "true" ]; then
        echo "ERROR: Test promotion not approved. Trigger promote:test first."
        exit 1
      fi
    - cd $TF_ROOT
    - !reference [.generate_backend, script]
    - terraform plan
        -var-file="$REPO_ROOT/examples/${TEST_EXAMPLE}/terraform.tfvars"
        -input=false
        -out=test.tfplan
    - terraform show -no-color test.tfplan | tee test-plan.txt
  artifacts:
    paths:
      - $TF_ROOT/test.tfplan
      - $TF_ROOT/test-plan.txt
    expire_in: 4 hours
  rules:
    - if: $CI_PIPELINE_SOURCE =~ /^(web|api)$/ && $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never

# =============================================================================
# STAGE 10: DEPLOY TEST (Manual - operator reviews plan first)
# =============================================================================

deploy:test:
  stage: deploy-test
  extends: [.aws_auth, .terraform_cache, .notify_failure]
  environment:
    name: test
    url: https://console.aws.amazon.com/bedrock/
  variables:
    AWS_ROLE_ARN: ${CI_ENVIRONMENT_ROLE_ARN_TEST}
    TF_STATE_BUCKET: ${TF_STATE_BUCKET_TEST}
    TF_STATE_APP_ID: ${TEST_TF_STATE_APP_ID}
    TF_STATE_AGENT_NAME: ${TEST_TF_STATE_AGENT_NAME}
    TF_VAR_environment: "test"
    TF_VAR_app_id: "agentcore-test"
    TF_VAR_lambda_architecture: "arm64"
  needs:
    - job: promote:test
      artifacts: true
    - job: plan:test
      artifacts: true
  resource_group: terraform-test
  timeout: 30m
  script:
    - |
      if [ "${PROMOTION_TO_TEST_APPROVED:-}" != "true" ]; then
        echo "ERROR: Test promotion not approved. Trigger promote:test first."
        exit 1
      fi
    - cd $TF_ROOT
    - echo "=== Plan to be applied ===" && cat test-plan.txt
    - !reference [.generate_backend, script]
    - |
      if ! terraform apply -auto-approve -input=false test.tfplan; then
        echo "ERROR: Deploy failed. Saving state snapshot for diagnostics."
        terraform state pull > failed-state-$(date +%s).json || echo "WARNING: Could not save state snapshot"
        exit 1
      fi
    - terraform output -json > outputs-test.json
  artifacts:
    paths:
      - $TF_ROOT/outputs-test.json
      - $TF_ROOT/failed-state-*.json
    expire_in: 30 days
  when: manual
  rules:
    - if: $CI_PIPELINE_SOURCE =~ /^(web|api)$/ && $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
    - when: never

smoke-test:test:
  stage: smoke-test-test
  extends: [.aws_auth, .notify_failure]
  image: python:3.12-slim
  needs:
    - job: promote:test
      artifacts: true
    - job: deploy:test
      artifacts: true
  variables:
    AWS_ROLE_ARN: ${CI_ENVIRONMENT_ROLE_ARN_TEST}
  script:
    - |
      if [ "${PROMOTION_TO_TEST_APPROVED:-}" != "true" ]; then
        echo "ERROR: Test promotion not approved. Trigger promote:test first."
        exit 1
      fi
    - pip install -q boto3
    - cd $TF_ROOT
    - python scripts/validate_bff.py
  rules:
    - if: $CI_PIPELINE_SOURCE =~ /^(web|api)$/ && $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never

# =============================================================================
# STAGE 11: GATE PROD (Require successful test promotion evidence)
# =============================================================================

gate:prod-from-test:
  stage: gate-prod
  extends: [.install_tools, .notify_failure]
  script:
    - |
      set -euo pipefail
      echo "Checking promotion gate for tag ${CI_COMMIT_TAG:-<none>} at SHA ${CI_COMMIT_SHA}"
      PIPELINES_JSON=$(curl -sS --fail --header "JOB-TOKEN: $CI_JOB_TOKEN" \
        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/pipelines?sha=$CI_COMMIT_SHA&status=success&per_page=100")
      MAIN_PIPELINE_IDS=$(printf '%s' "$PIPELINES_JSON" | jq -r '.[] | select(.ref == $main_ref) | .id' --arg main_ref "$CI_DEFAULT_BRANCH")
      if [ -z "$MAIN_PIPELINE_IDS" ]; then
        echo "ERROR: No successful $CI_DEFAULT_BRANCH pipeline found for this SHA. Promote through test first."
        exit 1
      fi

      GATE_PASSED=0
      GATE_SOURCE_PIPELINE_ID=""
      for PIPELINE_ID in $MAIN_PIPELINE_IDS; do
        JOBS_JSON=$(curl -sS --fail --header "JOB-TOKEN: $CI_JOB_TOKEN" \
          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/pipelines/${PIPELINE_ID}/jobs?per_page=100")
        job_success() {
          printf '%s' "$JOBS_JSON" | jq -e --arg job_name "$1" \
            '.[] | select(.name==$job_name and .status=="success")' >/dev/null
        }
        job_success_with_artifact() {
          printf '%s' "$JOBS_JSON" | jq -e --arg job_name "$1" \
            '.[] | select(.name==$job_name and .status=="success" and ((.artifacts_file.filename // "") | length > 0))' >/dev/null
        }
        if job_success_with_artifact "promote:dev" \
          && job_success_with_artifact "promote:test" \
          && job_success "deploy:test" \
          && job_success "smoke-test:test"; then
          echo "Promotion gate satisfied by main pipeline ID: ${PIPELINE_ID}"
          GATE_PASSED=1
          GATE_SOURCE_PIPELINE_ID="${PIPELINE_ID}"
          break
        fi
      done

      if [ "$GATE_PASSED" -ne 1 ]; then
        echo "ERROR: No successful main pipeline for this SHA contains promote:dev/promote:test evidence plus deploy:test + smoke-test:test."
        exit 1
      fi

      EVIDENCE_DIR="promotion-evidence"
      EVIDENCE_FILE="${EVIDENCE_DIR}/gate-prod-from-test-evidence-${CI_COMMIT_SHA}.json"
      mkdir -p "$EVIDENCE_DIR"
      cat > "$EVIDENCE_FILE" <<EOF
      {
        "gate": "gate:prod-from-test",
        "commit_sha": "${CI_COMMIT_SHA}",
        "tag": "${CI_COMMIT_TAG:-}",
        "pipeline_id": "${CI_PIPELINE_ID}",
        "job_id": "${CI_JOB_ID}",
        "verified_main_pipeline_id": "${GATE_SOURCE_PIPELINE_ID}",
        "verified_jobs": [
          "promote:dev (artifact evidence)",
          "promote:test (artifact evidence)",
          "deploy:test",
          "smoke-test:test"
        ],
        "verified_at_utc": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
      }
      EOF
      echo "Prod promotion gate evidence recorded at ${EVIDENCE_FILE}"
  artifacts:
    paths:
      - promotion-evidence/
    expire_in: 90 days
  rules:
    - if: $CI_COMMIT_TAG

# =============================================================================
# STAGE 12: PLAN PROD (Mandatory review before prod deploy)
# =============================================================================

plan:prod:
  stage: plan-prod
  extends: [.aws_auth, .terraform_cache, .notify_failure]
  environment:
    name: production
  variables:
    AWS_ROLE_ARN: ${CI_ENVIRONMENT_ROLE_ARN_PROD}
    TF_STATE_BUCKET: ${TF_STATE_BUCKET_PROD}
    TF_STATE_APP_ID: ${PROD_TF_STATE_APP_ID}
    TF_STATE_AGENT_NAME: ${PROD_TF_STATE_AGENT_NAME}
    TF_VAR_environment: "prod"
    TF_VAR_app_id: "agentcore-prod"
    TF_VAR_lambda_architecture: "arm64"
  needs: [gate:prod-from-test]
  script:
    - cd $TF_ROOT
    - !reference [.generate_backend, script]
    - terraform plan
        -var-file="$REPO_ROOT/examples/${PROD_EXAMPLE}/terraform.tfvars"
        -input=false
        -out=prod.tfplan
    - terraform show -no-color prod.tfplan | tee prod-plan.txt
    - |
      echo "=== PLAN SUMMARY ==="
      grep -E "^Plan:|will be created|will be destroyed|will be updated" prod-plan.txt || true
  artifacts:
    paths:
      - $TF_ROOT/prod.tfplan
      - $TF_ROOT/prod-plan.txt
    expire_in: 4 hours
  rules:
    - if: $CI_COMMIT_TAG

# =============================================================================
# STAGE 13: DEPLOY PROD (Manual - operator reviews plan output before approving)
# =============================================================================

deploy:prod:
  stage: deploy-prod
  extends: [.aws_auth, .terraform_cache, .notify_failure]
  environment:
    name: production
    url: https://console.aws.amazon.com/bedrock/
  variables:
    AWS_ROLE_ARN: ${CI_ENVIRONMENT_ROLE_ARN_PROD}
    TF_STATE_BUCKET: ${TF_STATE_BUCKET_PROD}
    TF_STATE_APP_ID: ${PROD_TF_STATE_APP_ID}
    TF_STATE_AGENT_NAME: ${PROD_TF_STATE_AGENT_NAME}
    TF_VAR_environment: "prod"
    TF_VAR_app_id: "agentcore-prod"
    TF_VAR_lambda_architecture: "arm64"
  needs: [plan:prod]
  resource_group: terraform-prod
  timeout: 60m
  script:
    - cd $TF_ROOT
    - echo "=== Plan to be applied ===" && cat prod-plan.txt
    - !reference [.generate_backend, script]
    - |
      if ! terraform apply -auto-approve -input=false prod.tfplan; then
        echo "ERROR: Prod deploy failed. Saving state snapshot for diagnostics."
        terraform state pull > failed-state-$(date +%s).json || echo "WARNING: Could not save state snapshot"
        exit 1
      fi
    - terraform output -json > outputs-prod.json
  artifacts:
    paths:
      - $TF_ROOT/outputs-prod.json
      - $TF_ROOT/failed-state-*.json
    expire_in: 90 days
  when: manual
  rules:
    - if: $CI_COMMIT_TAG

smoke-test:prod:
  stage: smoke-test-prod
  extends: [.aws_auth, .notify_failure]
  image: python:3.12-slim
  variables:
    AWS_ROLE_ARN: ${CI_ENVIRONMENT_ROLE_ARN_PROD}
  script:
    - pip install -q boto3
    - cd $TF_ROOT
    - python scripts/validate_bff.py
  rules:
    - if: $CI_COMMIT_TAG
      when: on_success

# =============================================================================
# SCHEDULED: DRIFT DETECTION (all environments)
# =============================================================================

.drift_template:
  stage: test
  extends: [.aws_auth, .notify_failure]
  script:
    - cd $TF_ROOT
    - !reference [.generate_backend, script]
    - |
      set +e
      terraform plan \
        -detailed-exitcode \
        -var-file="$REPO_ROOT/examples/${DRIFT_EXAMPLE}/terraform.tfvars" \
        -input=false
      EXIT_CODE=$?
      set -e
      case $EXIT_CODE in
        0) echo "✅ No drift detected in $CI_ENVIRONMENT_NAME" ;;
        2)
          echo "⚠️ DRIFT DETECTED in $CI_ENVIRONMENT_NAME"
          echo "Infrastructure differs from Terraform state."
          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            curl -s -X POST "$SLACK_WEBHOOK_URL" \
              -H 'Content-Type: application/json' \
              -d "{\"text\":\"⚠️ Drift detected in \`$CI_ENVIRONMENT_NAME\`\\nPipeline: $CI_PIPELINE_URL\"}"
          fi
          exit 1
          ;;
        *) echo "ERROR: terraform plan failed in $CI_ENVIRONMENT_NAME"; exit 1 ;;
      esac
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"

drift:dev:
  extends: .drift_template
  environment:
    name: dev
  variables:
    AWS_ROLE_ARN: ${CI_ENVIRONMENT_ROLE_ARN_DEV}
    TF_STATE_BUCKET: ${TF_STATE_BUCKET_DEV}
    TF_STATE_APP_ID: ${DEV_TF_STATE_APP_ID}
    TF_STATE_AGENT_NAME: ${DEV_TF_STATE_AGENT_NAME}
    TF_VAR_environment: "dev"
    DRIFT_EXAMPLE: ${DEV_EXAMPLE}

drift:test:
  extends: .drift_template
  environment:
    name: test
  variables:
    AWS_ROLE_ARN: ${CI_ENVIRONMENT_ROLE_ARN_TEST}
    TF_STATE_BUCKET: ${TF_STATE_BUCKET_TEST}
    TF_STATE_APP_ID: ${TEST_TF_STATE_APP_ID}
    TF_STATE_AGENT_NAME: ${TEST_TF_STATE_AGENT_NAME}
    TF_VAR_environment: "test"
    DRIFT_EXAMPLE: ${TEST_EXAMPLE}

drift:prod:
  extends: .drift_template
  environment:
    name: production
  variables:
    AWS_ROLE_ARN: ${CI_ENVIRONMENT_ROLE_ARN_PROD}
    TF_STATE_BUCKET: ${TF_STATE_BUCKET_PROD}
    TF_STATE_APP_ID: ${PROD_TF_STATE_APP_ID}
    TF_STATE_AGENT_NAME: ${PROD_TF_STATE_AGENT_NAME}
    TF_VAR_environment: "prod"
    DRIFT_EXAMPLE: ${PROD_EXAMPLE}
